// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
/**
 * Class that represents a poller that waits until a model has been trained.
 *
 * @internal
 */
export class BeginRecognizeContentPoller extends Poller {
    constructor(options) {
        const { client, source, contentType, updateIntervalInMs = 5000, resultId, onProgress, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginRecognizePollOperation(Object.assign(Object.assign({}, state), { client,
            source,
            contentType,
            resultId, status: "notStarted", analyzeOptions: options }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 *
 * @internal
 */
function makeBeginRecognizePollOperation(state) {
    return {
        state: Object.assign({}, state),
        async cancel(_options = {}) {
            throw new Error("Cancel operation is not supported.");
        },
        async update(options = {}) {
            var _a;
            const pollerState = this.state;
            const { client, source, contentType, analyzeOptions } = pollerState;
            if (!pollerState.isStarted) {
                if (!source) {
                    throw new Error("Expect a valid 'source'");
                }
                pollerState.isStarted = true;
                const result = await client.beginRecognize(source, contentType, analyzeOptions || {});
                if (!result.operationLocation) {
                    throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                }
                const lastSlashIndex = result.operationLocation.lastIndexOf("/");
                pollerState.resultId = result.operationLocation.substring(lastSlashIndex + 1);
                // source is no longer needed
                pollerState.source = undefined;
            }
            const response = await client.getRecognizeResult(pollerState.resultId, {
                abortSignal: analyzeOptions === null || analyzeOptions === void 0 ? void 0 : analyzeOptions.abortSignal
            });
            pollerState.status = response.status;
            if (!pollerState.isCompleted) {
                if (typeof options.fireProgress === "function") {
                    options.fireProgress(pollerState);
                }
                if (response.status === "succeeded") {
                    pollerState.result = response.pages;
                    pollerState.isCompleted = true;
                }
                else if (response.status === "failed") {
                    const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                    const message = `Content recognition failed.
Error(s):
${errors || ""}
`;
                    throw new Error(message);
                }
            }
            return makeBeginRecognizePollOperation(pollerState);
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client" || key === "source") {
                    return undefined;
                }
                return value;
            });
        }
    };
}
//# sourceMappingURL=contentPoller.js.map